#!/usr/bin/python

import numpy as np
import h5py
import arf
import ewave
from scipy.signal import resample
from continuous_arf import get_trials,classify_stim
import time
import os
from itertools import izip
import argparse
from scipy.signal import fftconvolve
  
def classify_stim(stimuli, stim_copies, sr=30000):
    '''Classifies stimuli if no stimulus log exists'''                         

    
    max_corr = lambda x,y: np.max(fftconvolve(x,y[::-1]))
    stim_idx = [np.argmax([max_corr(stim,copy) for stim in stimuli])
                for copy in stim_copies]

    return stim_idx

def dset_generator(arf_file, dataset_name):
    for entry in arf_file.itervalues():
        if isinstance(entry,h5py.Group) and entry.get(dataset_name):
            yield entry[dataset_name]

def label_stim(arfname, wavenames, stim_labels, pulse_key,
               copy_key, dset_name='stimulus_time', stimulus_group='stimuli'):


    with h5py.File(arfname,'r+') as arf_file:
        #obtain stimulus times
        #finds when pulse channel crosses threshold, then finds max around that time
        pulse_dsets = dset_generator(arf_file, pulse_key)
        copy_dsets = dset_generator(arf_file, copy_key)
        for pulse_dset,copy_dset in izip(pulse_dsets,copy_dsets):        
            thr = 200 * np.median(np.abs(pulse_dset[:])/.6745);#.6475 converts to estimator of std
            thresh_crossings = np.where(np.logical_and(pulse_dset[:-1]<thr, pulse_dset[1:]>thr))[0]
            starts = [t + np.argmax(pulse_dset[t:t+2000]) for t in thresh_crossings]

            # creating label dataset
            stim_list = [(s,'') for s in starts]
            stim_dtype = [('start',int), ('name', 'a%d'%(max(len(lb) for lb in stim_labels)))]
            stim_array = np.array(stim_list, dtype=stim_dtype)
            sr = pulse_dset.attrs['sampling_rate']
            label_dset = arf.create_dataset(pulse_dset.parent, dset_name, data=stim_array,
                                            datatype = 2001, units = ('samples', ''), sampling_rate=sr)

            #classifying stimuli
            copy_sr = copy_dset.attrs['sampling_rate']
            wav_files = [ewave.open(wav) for wav in wavenames]
            resampled_wavs = [resample(f.read(),copy_sr*f.nframes/float(f.sampling_rate))
                              for f in wav_files]
            max_stim_len = max(len(w) for w in resampled_wavs)
            stim_copies = [copy_dset[s:min(s+max_stim_len,copy_dset.size)] for s in starts] 
            stim_idx = classify_stim(resampled_wavs, stim_copies)
            name = np.array(stim_labels)[stim_idx]
            label_dset['name'] = name

        #saving stimuli
        arf.create_entry(arf_file, stimulus_group, time.time())
        for i,f in enumerate(wav_files):
            arf.create_dataset(arf_file[stimulus_group], stim_labels[i], data=f.read(),
                               datatype=1, sampling_rate=f.sampling_rate,
                               original_file=os.path.abspath(wavenames[i]))

def main():
    p = argparse.ArgumentParser(prog='label stimulus', description="""Creates label datasets containing stimulus times and labels and saves stimulus wave files in arf""",formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    p.add_argument("arf",help='Name of arf file to label')
    p.add_argument("-w","--wavenames",help="""Stimulus wave files""",nargs="+")
    p.add_argument("-l","--labels", help="""Labels for each stimulus""",nargs="+")
    p.add_argument("-p","--pulse_channel",help="""Name of pulse channel""")
    p.add_argument("-c","--copy_channel", help="""Name of stimulus copy channel""")
    p.add_argument("-d","--dataset_name", help="""Name of label datasets to be created""", default="stimulus_time")
    p.add_argument("-s","--stimulus_group",help="""Name of the group in the arf file containing the stimuli""",default="stimuli")

    options=p.parse_args()
    label_stim(options.arf,options.wavenames,
               options.labels,options.pulse_channel,
               options.copy_channel,options.dataset_name,
               options.stimulus_group)
if __name__=='__main__':
    main()